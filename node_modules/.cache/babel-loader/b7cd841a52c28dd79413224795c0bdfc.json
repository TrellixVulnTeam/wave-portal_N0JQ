{"ast":null,"code":"import { ethers } from 'ethers';\nimport { CONTACT_ADDRESS } from '../util/constants';\nimport contractABI from '../util/WavePortal.json';\n\nconst createWaveTxn = async messageText => {\n  try {\n    const {\n      ethereum\n    } = window;\n    const provider = new ethers.providers.Web3Provider(ethereum);\n    const signer = provider.getSigner();\n    const contract = new ethers.Contract(CONTACT_ADDRESS, contractABI.abi, signer);\n\n    if (contract !== undefined) {\n      const waveTxn = await contract.sendWave(messageText, {\n        gasLimit: 300000\n      });\n      console.log('Mining... ', waveTxn.hash);\n      await waveTxn.wait();\n      console.log('Mined--', waveTxn.hash);\n    }\n  } catch (error) {\n    console.log(error);\n  }\n};\n\nconst getWaveCount = async (setWaveCount) => {\n  try {\n    const {\n      ethereum\n    } = window;\n    const provider = new ethers.providers.Web3Provider(ethereum);\n    const signer = provider.getSigner();\n    const contract = new ethers.Contract(CONTACT_ADDRESS, contractABI.abi, signer);\n    const count = await contract.getTotalWaves();\n    console.log('returned total waves count: ', count);\n    setWaveCount(count);\n  } catch (error) {\n    console.log(error);\n  }\n};\n\nconst getAllWaves = async setWaves => {\n  const {\n    ethereum\n  } = window;\n\n  try {\n    if (window.ethereum) {\n      const provider = new ethers.providers.Web3Provider(ethereum);\n      const signer = provider.getSigner();\n      const contract = new ethers.Contract(CONTACT_ADDRESS, contractABI.abi, signer);\n      const waves = await contract.getAllWaves();\n      let wavesCleaned = [];\n      waves.forEach(wave => {\n        wavesCleaned.push({\n          address: wave.waver,\n          timestamp: new Date(wave.timestamp * 1000),\n          message: wave.message\n        });\n      });\n      console.log(wavesCleaned);\n      const testWaves = waves.map(wave => {\n        wave.address, new Date(wave.timestamp * 1000), wave.mesasge;\n      });\n      console.log(testWaves);\n      setWaves(wavesCleaned);\n      contract.on('NewWave', (from, timestamp, message) => {\n        console.log('NewWave', from, timestamp, message);\n        setWaves(prevState => [...prevState, {\n          address: from,\n          timestamp: new Date(timestamp * 1000),\n          message: message\n        }]);\n      });\n    } else {\n      console.log('Ethereum object does not exist!');\n    }\n  } catch (error) {\n    console.log(error);\n  }\n};\n\nconst listenForNewWaves = async (waves, setWaves) => {\n  const {\n    ethereum\n  } = window;\n\n  try {\n    if (window.ethereum) {\n      const provider = new ethers.providers.Web3Provider(ethereum);\n      const signer = provider.getSigner();\n      const contract = new ethers.Contract(CONTACT_ADDRESS, contractABI.abi, signer);\n      contract.on('NewWave', (from, timestamp, message) => {\n        console.log('NewWave', from, timestamp, message);\n        setWaves(() => [...waves, {\n          address: from,\n          timestamp: new Date(timestamp * 1000),\n          message: message\n        }]);\n      });\n    } else {\n      console.log('Ethereum object does not exist!');\n    }\n  } catch (error) {\n    console.log(error);\n  }\n};\n\nexport const EthereumService = {\n  createWaveTxn,\n  getWaveCount,\n  getAllWaves,\n  listenForNewWaves\n};","map":{"version":3,"sources":["/Users/calvin/blockchain/wave-portal/src/service/index.ts"],"names":["ethers","CONTACT_ADDRESS","contractABI","createWaveTxn","messageText","ethereum","window","provider","providers","Web3Provider","signer","getSigner","contract","Contract","abi","undefined","waveTxn","sendWave","gasLimit","console","log","hash","wait","error","getWaveCount","setWaveCount","count","getTotalWaves","getAllWaves","setWaves","waves","wavesCleaned","forEach","wave","push","address","waver","timestamp","Date","message","testWaves","map","mesasge","on","from","prevState","listenForNewWaves","EthereumService"],"mappings":"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","sourcesContent":["\nimport React from 'react';\nimport { ethers } from 'ethers';\nimport { CONTACT_ADDRESS } from '../util/constants';\nimport contractABI from '../util/WavePortal.json';\nimport { Wave } from '../model/wave';\n\ndeclare let window: any;\n\nconst createWaveTxn = async (messageText: string) => {\n  try {\n    const { ethereum }: any = window;\n    const provider = new ethers.providers.Web3Provider(ethereum);\n    const signer = provider.getSigner();\n    const contract = new ethers.Contract(CONTACT_ADDRESS, contractABI.abi, signer);\n\n    if (contract !== undefined) {\n      const waveTxn = await contract.sendWave(messageText, { gasLimit: 300000 });\n      console.log('Mining... ', waveTxn.hash);\n\n      await waveTxn.wait();\n      console.log('Mined--', waveTxn.hash);\n    }\n  } catch (error) {\n    console.log(error);\n  }\n};\n\nconst getWaveCount = async (\n  setWaveCount: React.Dispatch<React.SetStateAction<number>>\n) => {\n  try {\n    const { ethereum }: any = window;\n    const provider = new ethers.providers.Web3Provider(ethereum);\n    const signer = provider.getSigner();\n    const contract = new ethers.Contract(CONTACT_ADDRESS, contractABI.abi, signer);\n\n    const count = await contract.getTotalWaves();\n    console.log('returned total waves count: ', count);\n    setWaveCount(count);\n  } catch (error) {\n    console.log(error);\n  }\n};\n\nconst getAllWaves = async (setWaves: React.Dispatch<React.SetStateAction<Wave[]>>)=> {\n  const { ethereum } = window;\n  try {\n    if (window.ethereum) { \n      const provider = new ethers.providers.Web3Provider(ethereum);\n      const signer = provider.getSigner();\n      const contract = new ethers.Contract(CONTACT_ADDRESS, contractABI.abi, signer);\n  \n      const waves = await contract.getAllWaves();\n      let wavesCleaned: Wave[] = [];\n\n      waves.forEach((wave: any) => {\n        wavesCleaned.push({\n          address: wave.waver,\n          timestamp: new Date(wave.timestamp * 1000),\n          message: wave.message\n        } as Wave);\n      });\n\n      console.log(wavesCleaned);\n\n      const testWaves: Wave[] = waves.map((wave: any) => {\n        wave.address,\n        new Date(wave.timestamp * 1000),\n        wave.mesasge\n      });\n      console.log(testWaves);\n      setWaves(wavesCleaned);\n\n      contract.on('NewWave', (from, timestamp, message) => {\n        console.log('NewWave', from, timestamp, message);\n\n        setWaves(prevState => [...prevState, {\n          address: from,\n          timestamp: new Date(timestamp * 1000),\n          message: message\n        } as Wave]);\n      });\n    } else {\n      console.log('Ethereum object does not exist!');\n    }\n  } catch (error) {\n    console.log(error);\n  }\n};\n\nconst listenForNewWaves = async (\n  waves: Wave[],\n  setWaves: React.Dispatch<React.SetStateAction<Wave[]>>\n) => {\n  const { ethereum } = window;\n\n  try {\n    if (window.ethereum) {\n      const provider = new ethers.providers.Web3Provider(ethereum);\n      const signer = provider.getSigner();\n      const contract = new ethers.Contract(CONTACT_ADDRESS, contractABI.abi, signer);\n\n      contract.on('NewWave', (from, timestamp, message) => {\n        console.log('NewWave', from, timestamp, message);\n\n        setWaves(() => [...waves, {\n          address: from,\n          timestamp: new Date(timestamp * 1000),\n          message: message\n        } as Wave]);\n      });\n\n\n    } else {\n      console.log('Ethereum object does not exist!'); \n    }\n  } catch (error) {\n    console.log(error);\n  }\n};\n\nexport const EthereumService = {\n  createWaveTxn,\n  getWaveCount,\n  getAllWaves,\n  listenForNewWaves,\n}"]},"metadata":{},"sourceType":"module"}