{"ast":null,"code":"import { ethers } from 'ethers';\nimport { CONTACT_ADDRESS } from '../util/constants';\nimport contractABI from '../util/WavePortal.json';\nexport const createWaveTxn = async messageText => {\n  try {\n    const {\n      ethereum\n    } = window;\n    const provider = new ethers.providers.Web3Provider(ethereum);\n    const signer = provider.getSigner();\n    const contract = new ethers.Contract(CONTACT_ADDRESS, contractABI.abi, signer);\n\n    if (contract !== undefined) {\n      const waveTxn = await contract.wave(messageText, {\n        gasLimit: 300000\n      });\n      console.log('Mining... ', waveTxn.hash);\n      await waveTxn.wait();\n      console.log('Mined--', waveTxn.hash);\n    }\n  } catch (error) {\n    console.log(error);\n  }\n};\nexport const getWaveCount = async () => {\n  try {\n    const {\n      ethereum\n    } = window;\n    const provider = new ethers.providers.Web3Provider(ethereum);\n    const signer = provider.getSigner();\n    const contract = new ethers.Contract(CONTACT_ADDRESS, contractABI.abi, signer);\n    const count = await contract.getTotalWaves();\n    console.log('returned total waves count: ', count);\n    const x = Number(count);\n    console.log(x);\n    return count;\n  } catch (error) {\n    console.log(error);\n    return undefined;\n  }\n};\nexport const getWaves = async () => {\n  const {\n    ethereum\n  } = window;\n\n  try {\n    if (window.ethereum) {\n      const provider = new ethers.providers.Web3Provider(ethereum);\n      const signer = provider.getSigner();\n      const contract = new ethers.Contract(CONTACT_ADDRESS, contractABI.abi, signer);\n      const waves = await contract.getAllWaves();\n      let wavesCleaned = [];\n      waves.forEach(wave => {\n        const timestamp = new Date(wave.timestamp * 1000).toString();\n        const formattedTimeStamp = timestamp.split(' (')[0];\n        wavesCleaned.push({\n          address: wave.waver,\n          timestamp: formattedTimeStamp,\n          message: wave.message\n        });\n      });\n      console.log(wavesCleaned);\n      return wavesCleaned;\n    } else {\n      console.log('Ethereum object does not exist!');\n      return undefined;\n    }\n  } catch (error) {\n    console.log(error);\n    return undefined;\n  }\n};\nexport const listenForNewWaves = async setWaves => {\n  console.log('listening for new waves!');\n  const {\n    ethereum\n  } = window;\n\n  try {\n    if (window.ethereum) {\n      const provider = new ethers.providers.Web3Provider(ethereum);\n      const signer = provider.getSigner();\n      const contract = new ethers.Contract(CONTACT_ADDRESS, contractABI.abi, signer);\n      contract.on('NewWave', async (from, timestamp, message) => {\n        console.log('NewWave', from, timestamp, message);\n        const waves = await contract.getAllWaves();\n        setWaves(waves);\n        setWaves(prevState => [...prevState, {\n          address: from,\n          timestamp: new Date(timestamp * 1000).toString(),\n          message: message\n        }]);\n      });\n    } else {\n      console.log('Ethereum object does not exist!');\n    }\n  } catch (error) {\n    console.log(error);\n  }\n};","map":{"version":3,"sources":["/Users/calvin/blockchain/wave-portal/src/service/index.ts"],"names":["ethers","CONTACT_ADDRESS","contractABI","createWaveTxn","messageText","ethereum","window","provider","providers","Web3Provider","signer","getSigner","contract","Contract","abi","undefined","waveTxn","wave","gasLimit","console","log","hash","wait","error","getWaveCount","count","getTotalWaves","x","Number","getWaves","waves","getAllWaves","wavesCleaned","forEach","timestamp","Date","toString","formattedTimeStamp","split","push","address","waver","message","listenForNewWaves","setWaves","on","from","prevState"],"mappings":"AAEA,SAASA,MAAT,QAAuB,QAAvB;AACA,SAASC,eAAT,QAAgC,mBAAhC;AACA,OAAOC,WAAP,MAAwB,yBAAxB;AAMA,OAAO,MAAMC,aAAa,GAAG,MAAOC,WAAP,IAA+B;AAC1D,MAAI;AACF,UAAM;AAAEC,MAAAA;AAAF,QAAoBC,MAA1B;AACA,UAAMC,QAAQ,GAAG,IAAIP,MAAM,CAACQ,SAAP,CAAiBC,YAArB,CAAkCJ,QAAlC,CAAjB;AACA,UAAMK,MAAM,GAAGH,QAAQ,CAACI,SAAT,EAAf;AACA,UAAMC,QAAQ,GAAG,IAAIZ,MAAM,CAACa,QAAX,CAAoBZ,eAApB,EAAqCC,WAAW,CAACY,GAAjD,EAAsDJ,MAAtD,CAAjB;;AAEA,QAAIE,QAAQ,KAAKG,SAAjB,EAA4B;AAC1B,YAAMC,OAAO,GAAG,MAAMJ,QAAQ,CAACK,IAAT,CAAcb,WAAd,EAA2B;AAAEc,QAAAA,QAAQ,EAAE;AAAZ,OAA3B,CAAtB;AACAC,MAAAA,OAAO,CAACC,GAAR,CAAY,YAAZ,EAA0BJ,OAAO,CAACK,IAAlC;AAEA,YAAML,OAAO,CAACM,IAAR,EAAN;AACAH,MAAAA,OAAO,CAACC,GAAR,CAAY,SAAZ,EAAuBJ,OAAO,CAACK,IAA/B;AACD;AACF,GAbD,CAaE,OAAOE,KAAP,EAAc;AACdJ,IAAAA,OAAO,CAACC,GAAR,CAAYG,KAAZ;AACD;AACF,CAjBM;AAmBP,OAAO,MAAMC,YAAY,GAAG,YAAyC;AACnE,MAAI;AACF,UAAM;AAAEnB,MAAAA;AAAF,QAAoBC,MAA1B;AACA,UAAMC,QAAQ,GAAG,IAAIP,MAAM,CAACQ,SAAP,CAAiBC,YAArB,CAAkCJ,QAAlC,CAAjB;AACA,UAAMK,MAAM,GAAGH,QAAQ,CAACI,SAAT,EAAf;AACA,UAAMC,QAAQ,GAAG,IAAIZ,MAAM,CAACa,QAAX,CAAoBZ,eAApB,EAAqCC,WAAW,CAACY,GAAjD,EAAsDJ,MAAtD,CAAjB;AAEA,UAAMe,KAAK,GAAG,MAAMb,QAAQ,CAACc,aAAT,EAApB;AACAP,IAAAA,OAAO,CAACC,GAAR,CAAY,8BAAZ,EAA4CK,KAA5C;AAEA,UAAME,CAAC,GAAGC,MAAM,CAACH,KAAD,CAAhB;AACAN,IAAAA,OAAO,CAACC,GAAR,CAAYO,CAAZ;AACA,WAAOF,KAAP;AAED,GAbD,CAaE,OAAOF,KAAP,EAAc;AACdJ,IAAAA,OAAO,CAACC,GAAR,CAAYG,KAAZ;AACA,WAAOR,SAAP;AACD;AACF,CAlBM;AAoBP,OAAO,MAAMc,QAAQ,GAAG,YAAY;AAClC,QAAM;AAAExB,IAAAA;AAAF,MAAeC,MAArB;;AACA,MAAI;AACF,QAAIA,MAAM,CAACD,QAAX,EAAqB;AACnB,YAAME,QAAQ,GAAG,IAAIP,MAAM,CAACQ,SAAP,CAAiBC,YAArB,CAAkCJ,QAAlC,CAAjB;AACA,YAAMK,MAAM,GAAGH,QAAQ,CAACI,SAAT,EAAf;AACA,YAAMC,QAAQ,GAAG,IAAIZ,MAAM,CAACa,QAAX,CAAoBZ,eAApB,EAAqCC,WAAW,CAACY,GAAjD,EAAsDJ,MAAtD,CAAjB;AAEA,YAAMoB,KAAK,GAAG,MAAMlB,QAAQ,CAACmB,WAAT,EAApB;AACA,UAAIC,YAAoB,GAAG,EAA3B;AAEAF,MAAAA,KAAK,CAACG,OAAN,CAAehB,IAAD,IAAe;AAC3B,cAAMiB,SAAS,GAAG,IAAIC,IAAJ,CAASlB,IAAI,CAACiB,SAAL,GAAiB,IAA1B,EAAgCE,QAAhC,EAAlB;AACA,cAAMC,kBAAkB,GAAGH,SAAS,CAACI,KAAV,CAAgB,IAAhB,EAAsB,CAAtB,CAA3B;AAEAN,QAAAA,YAAY,CAACO,IAAb,CAAkB;AAChBC,UAAAA,OAAO,EAAEvB,IAAI,CAACwB,KADE;AAEhBP,UAAAA,SAAS,EAAEG,kBAFK;AAGhBK,UAAAA,OAAO,EAAEzB,IAAI,CAACyB;AAHE,SAAlB;AAKD,OATD;AAWAvB,MAAAA,OAAO,CAACC,GAAR,CAAYY,YAAZ;AACA,aAAOA,YAAP;AACD,KArBD,MAqBO;AACLb,MAAAA,OAAO,CAACC,GAAR,CAAY,iCAAZ;AACA,aAAOL,SAAP;AACD;AACF,GA1BD,CA0BE,OAAOQ,KAAP,EAAc;AACdJ,IAAAA,OAAO,CAACC,GAAR,CAAYG,KAAZ;AACA,WAAOR,SAAP;AACD;AACF,CAhCM;AAkCP,OAAO,MAAM4B,iBAAiB,GAAG,MAAOC,QAAP,IAAkE;AACjGzB,EAAAA,OAAO,CAACC,GAAR,CAAY,0BAAZ;AACA,QAAM;AAAEf,IAAAA;AAAF,MAAeC,MAArB;;AACA,MAAI;AACF,QAAIA,MAAM,CAACD,QAAX,EAAqB;AACnB,YAAME,QAAQ,GAAG,IAAIP,MAAM,CAACQ,SAAP,CAAiBC,YAArB,CAAkCJ,QAAlC,CAAjB;AACA,YAAMK,MAAM,GAAGH,QAAQ,CAACI,SAAT,EAAf;AACA,YAAMC,QAAQ,GAAG,IAAIZ,MAAM,CAACa,QAAX,CAAoBZ,eAApB,EAAqCC,WAAW,CAACY,GAAjD,EAAsDJ,MAAtD,CAAjB;AAEAE,MAAAA,QAAQ,CAACiC,EAAT,CAAY,SAAZ,EAAuB,OAAOC,IAAP,EAAaZ,SAAb,EAAwBQ,OAAxB,KAAoC;AACzDvB,QAAAA,OAAO,CAACC,GAAR,CAAY,SAAZ,EAAuB0B,IAAvB,EAA6BZ,SAA7B,EAAwCQ,OAAxC;AAEA,cAAMZ,KAAK,GAAG,MAAMlB,QAAQ,CAACmB,WAAT,EAApB;AACAa,QAAAA,QAAQ,CAACd,KAAD,CAAR;AACAc,QAAAA,QAAQ,CAACG,SAAS,IAAI,CAAC,GAAGA,SAAJ,EAAe;AACnCP,UAAAA,OAAO,EAAEM,IAD0B;AAEnCZ,UAAAA,SAAS,EAAG,IAAIC,IAAJ,CAASD,SAAS,GAAG,IAArB,EAA2BE,QAA3B,EAFuB;AAGnCM,UAAAA,OAAO,EAAEA;AAH0B,SAAf,CAAd,CAAR;AAKD,OAVD;AAWD,KAhBD,MAgBO;AACLvB,MAAAA,OAAO,CAACC,GAAR,CAAY,iCAAZ;AACD;AACF,GApBD,CAoBE,OAAOG,KAAP,EAAc;AACdJ,IAAAA,OAAO,CAACC,GAAR,CAAYG,KAAZ;AACD;AACF,CA1BM","sourcesContent":["\nimport React from 'react';\nimport { ethers } from 'ethers';\nimport { CONTACT_ADDRESS } from '../util/constants';\nimport contractABI from '../util/WavePortal.json';\nimport { Wave } from '../model/wave';\nimport { format } from 'path';\n\ndeclare let window: any;\n\nexport const createWaveTxn = async (messageText: string) => {\n  try {\n    const { ethereum }: any = window;\n    const provider = new ethers.providers.Web3Provider(ethereum);\n    const signer = provider.getSigner();\n    const contract = new ethers.Contract(CONTACT_ADDRESS, contractABI.abi, signer);\n\n    if (contract !== undefined) {\n      const waveTxn = await contract.wave(messageText, { gasLimit: 300000 });\n      console.log('Mining... ', waveTxn.hash);\n\n      await waveTxn.wait();\n      console.log('Mined--', waveTxn.hash);\n    }\n  } catch (error) {\n    console.log(error);\n  }\n};\n\nexport const getWaveCount = async (): Promise<number | undefined> => {\n  try {\n    const { ethereum }: any = window;\n    const provider = new ethers.providers.Web3Provider(ethereum);\n    const signer = provider.getSigner();\n    const contract = new ethers.Contract(CONTACT_ADDRESS, contractABI.abi, signer);\n\n    const count = await contract.getTotalWaves();\n    console.log('returned total waves count: ', count);\n\n    const x = Number(count);\n    console.log(x);\n    return count;\n\n  } catch (error) {\n    console.log(error);\n    return undefined;\n  }\n};\n\nexport const getWaves = async () => {\n  const { ethereum } = window;\n  try {\n    if (window.ethereum) { \n      const provider = new ethers.providers.Web3Provider(ethereum);\n      const signer = provider.getSigner();\n      const contract = new ethers.Contract(CONTACT_ADDRESS, contractABI.abi, signer);\n  \n      const waves = await contract.getAllWaves();\n      let wavesCleaned: Wave[] = [];\n\n      waves.forEach((wave: any) => {\n        const timestamp = new Date(wave.timestamp * 1000).toString()\n        const formattedTimeStamp = timestamp.split(' (')[0];\n\n        wavesCleaned.push({\n          address: wave.waver,\n          timestamp: formattedTimeStamp,\n          message: wave.message\n        });\n      });\n\n      console.log(wavesCleaned);\n      return wavesCleaned;\n    } else {\n      console.log('Ethereum object does not exist!');\n      return undefined;\n    }\n  } catch (error) {\n    console.log(error);\n    return undefined;\n  }\n};\n\nexport const listenForNewWaves = async (setWaves: React.Dispatch<React.SetStateAction<Wave[]>>) => {\n  console.log('listening for new waves!');\n  const { ethereum } = window;\n  try {\n    if (window.ethereum) {\n      const provider = new ethers.providers.Web3Provider(ethereum);\n      const signer = provider.getSigner();\n      const contract = new ethers.Contract(CONTACT_ADDRESS, contractABI.abi, signer);\n\n      contract.on('NewWave', async (from, timestamp, message) => {\n        console.log('NewWave', from, timestamp, message);\n\n        const waves = await contract.getAllWaves();\n        setWaves(waves);\n        setWaves(prevState => [...prevState, {\n          address: from,\n          timestamp: (new Date(timestamp * 1000).toString()),\n          message: message\n        } as Wave]);\n      });\n    } else {\n      console.log('Ethereum object does not exist!'); \n    }\n  } catch (error) {\n    console.log(error);\n  }\n};\n"]},"metadata":{},"sourceType":"module"}